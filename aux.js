// Generated by IcedCoffeeScript 1.7.1-f
(function() {
  var chinesedict, client, coffee, deferred, edict, edictText, englishdict, fs, getchinese_gloss, getpinyin, getprononciation, http_get, iced, japanesedict, jdict, jdictText, language, main, pinyinutils, print, redis, root, subpread, subtitleread, targetLanguage, translator, __iced_k, __iced_k_noop;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  print = console.log;

  fs = require('fs');

  http_get = require('http-get');

  root.portnum = 3000;

  coffee = require('iced-coffee-script');

  deferred = require('deferred');

  subtitleread = require('./static/subtitleread');

  subpread = require('./static/subpread');

  chinesedict = require('./static/chinesedict');

  japanesedict = require('./static/japanesedict');

  englishdict = require('./static/englishdict');

  jdictText = fs.readFileSync('static/edict2_full.txt', 'utf8');

  jdict = new japanesedict.JapaneseDict(jdictText);

  edictText = fs.readFileSync('static/engdict-opted.html', 'utf8');

  edict = new englishdict.EnglishDict(edictText);

  redis = require('redis');

  client = redis.createClient();

  getpinyin = require('./getpinyin');

  pinyinutils = require('./static/pinyinutils');

  getprononciation = require('./getprononciation');

  translator = require('./translator');

  getchinese_gloss = require('./getchinese_gloss');

  language = 'zh';

  targetLanguage = 'en';

  root.initializeUser = function(nuser) {
    var dlog, downloadSubtitleText, fixPinyin, fixSegmentation, getAnnotatedSubAtTime, getAnnotatedSubAtTimeChinese, getAnnotatedSubAtTimeEnglish, getAnnotatedSubAtTimeJapanese, getFullAnnotatedSub, getFullAnnotatedSubChinese, getFullAnnotatedSubEnglish, getFullAnnotatedSubJapanese, getGlossChinese, getNativeSubAtTime, getNextDialogStartTime, getPrevDialogStartTime, getSubPixAtTime, getTranslations, groupWordsFast, groupWordsLong, groupWordsLongPreservingPinyin, initializeNativeSubtitle, initializeNativeSubtitleText, initializeSubPix, initializeSubtitle, initializeSubtitleText, lookupDataForWord, nativeSubtitleGetter, serverlog, subPixGetter, subtitleGetter;
    subtitleGetter = null;
    nativeSubtitleGetter = {
      subtitleAtTimeAsync: function(deciSec, callback) {
        var idx, subtext;
        idx = subtitleGetter.getSubtitleIndexFromTime(deciSec);
        subtext = subtitleGetter.timesAndSubtitles[idx][2];
        return getTranslations(subtext, function(translation) {
          return callback(translation[0].TranslatedText);
        });
      }
    };
    subPixGetter = null;
    dlog = function(text) {
      serverlog(text);
      return nuser.now.clientlog(text);
    };
    initializeSubtitle = function(subtitleSource, nlanguage, tlanguage, doneCallback) {
      if ((subtitleSource == null) || subtitleSource === '') {
        return;
      }
      return downloadSubtitleText(subtitleSource, function(subtext) {
        return initializeSubtitleText(subtext, nlanguage, tlanguage, doneCallback);
      });
    };
    initializeNativeSubtitle = function(subtitleSource, doneCallback) {
      if ((subtitleSource == null) || subtitleSource === '') {
        return;
      }
      return downloadSubtitleText(subtitleSource, function(subtext) {
        return initializeNativeSubtitleText(subtext, doneCallback);
      });
    };
    initializeSubtitleText = function(subtitleText, nlanguage, tlanguage, doneCallback) {
      language = nlanguage;
      targetLanguage = tlanguage;
      subtitleGetter = new subtitleread.SubtitleRead(subtitleText);
      if (doneCallback != null) {
        return doneCallback();
      }
    };
    initializeNativeSubtitleText = function(subtitleText, doneCallback) {
      var nativeSubtitleGetterReal;
      nativeSubtitleGetterReal = new subtitleread.SubtitleRead(subtitleText);
      nativeSubtitleGetter = {
        subtitleAtTimeAsync: function(deciSec, callback) {
          var end, idx, isOverHalfOfNativeOrTargetCovered, nend, nstart, nsubtext, start, subtext, translations, _ref, _ref1, _ref2;
          idx = subtitleGetter.getSubtitleIndexFromTime(deciSec);
          _ref = subtitleGetter.timesAndSubtitles[idx], start = _ref[0], end = _ref[1], subtext = _ref[2];
          idx = nativeSubtitleGetterReal.getSubtitleIndexFromTime((start + end) / 2);

          /*
          subtextWords = getchinese_gloss.getEnglishWordsInGloss(subtext, (glossWords) ->
            translations = []
            if nativeSubtitleGetterReal.timesAndSubtitles[idx-1]?
              curtrans = nativeSubtitleGetterReal.timesAndSubtitles[idx-1][2]
              if getchinese_gloss.sentenceOverlapPercentageWithWords(curtrans, glossWords) > 0.1
                translations.push curtrans
            translations.push nativeSubtitleGetterReal.timesAndSubtitles[idx][2]
            if nativeSubtitleGetterReal.timesAndSubtitles[idx+1]?
              curtrans = nativeSubtitleGetterReal.timesAndSubtitles[idx+1][2]
              if getchinese_gloss.sentenceOverlapPercentageWithWords(curtrans, glossWords) > 0.1
                translations.push curtrans
            callback translations.join(' | ')
          )
           */
          isOverHalfOfNativeOrTargetCovered = function(start_target, end_target, start_native, end_native) {
            var covered_duration, native_duration, target_duration;
            target_duration = end - start;
            native_duration = end_native - start_native;
            covered_duration = Math.min(end_native, end_target) - Math.max(start_target, start_native);
            return covered_duration * 2 > Math.min(native_duration, target_duration);
          };
          while (idx >= 0) {
            _ref1 = nativeSubtitleGetterReal.timesAndSubtitles[idx], nstart = _ref1[0], nend = _ref1[1], nsubtext = _ref1[2];
            if (!isOverHalfOfNativeOrTargetCovered(start, end, nstart, nend)) {
              break;
            }
            idx -= 1;
          }
          if (idx !== 0) {
            idx += 1;
          }
          translations = [];
          while (idx < nativeSubtitleGetterReal.timesAndSubtitles.length) {
            _ref2 = nativeSubtitleGetterReal.timesAndSubtitles[idx], nstart = _ref2[0], nend = _ref2[1], nsubtext = _ref2[2];
            if (translations.length > 0 && !isOverHalfOfNativeOrTargetCovered(start, end, nstart, nend)) {
              break;
            }
            translations.push(nsubtext);
            idx += 1;
          }
          return callback(translations.join(' '));
        }
      };
      if (doneCallback != null) {
        return doneCallback();
      }
    };
    initializeSubPix = function(subPixSource) {
      if ((subPixSource == null) || subPixSource === '') {
        return;
      }
      return downloadSubtitleText(subPixSource, function(subPixText) {
        var subPixDir;
        subPixDir = '';
        if (subPixSource.lastIndexOf('/') !== -1) {
          subPixDir = subPixSource.slice(0, +subPixSource.lastIndexOf('/') + 1 || 9e9);
        }
        return subPixGetter = new subpread.SubpRead(subPixText, subPixDir);
      });
    };
    downloadSubtitleText = function(subtitleSource, callback) {
      if (subtitleSource.indexOf('http://') === -1) {
        subtitleSource = 'http://localhost:' + root.portnum + '/' + subtitleSource;
      }
      return http_get.get({
        url: subtitleSource
      }, function(err, dlData) {
        var data;
        data = dlData.buffer;
        return callback(data);
      });
    };
    getPrevDialogStartTime = function(time, callback) {
      var cursub, prevsub;
      time -= 1;
      while (time > 0) {
        prevsub = subtitleGetter.subtitleAtTime(time - 1);
        cursub = subtitleGetter.subtitleAtTime(time);
        if ((cursub != null) && cursub !== '' && prevsub !== cursub) {
          break;
        }
        --time;
      }
      if (time < 0) {
        time = 0;
      }
      return callback(time);
    };
    getNextDialogStartTime = function(time, callback) {
      var cursub, nextsub, origSub, prevsub;
      origSub = subtitleGetter.subtitleAtTime(time);
      ++time;
      while (time < subtitleGetter.lastStartTime) {
        nextsub = subtitleGetter.subtitleAtTime(time + 1);
        cursub = subtitleGetter.subtitleAtTime(time);
        if ((cursub != null) && cursub !== '' && cursub !== origSub && nextsub !== cursub) {
          break;
        }
        ++time;
      }
      if (time >= subtitleGetter.lastStartTime) {
        callback(time);
        return;
      }
      while (time > 0) {
        prevsub = subtitleGetter.subtitleAtTime(time - 1);
        cursub = subtitleGetter.subtitleAtTime(time);
        if ((cursub != null) && cursub !== '' && prevsub !== cursub) {
          break;
        }
        --time;
      }
      if (time < 0) {
        time = 0;
      }
      return callback(time);
    };
    fixPinyin = function(pinyin) {
      var dt, ft;
      pinyin = pinyin.toLowerCase();
      ft = ["'", 'zěnmeliǎo'];
      dt = ['', 'zěnmele'];
      return pinyinutils.replaceAllList(pinyin, ft, dt);
    };
    lookupDataForWord = function(word) {
      return [word, cdict.getPinyinForWord(word), cdict.getEnglishForWord(word)];
    };
    groupWordsFast = function(wordsWithPinyinAndTrans) {
      var curWordData, i, proposedWordChars, proposedWordData, _i, _ref;
      if (wordsWithPinyinAndTrans.length === 0) {
        return [];
      }
      curWordData = wordsWithPinyinAndTrans[0];
      for (i = _i = 1, _ref = wordsWithPinyinAndTrans.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        proposedWordChars = curWordData[0] + wordsWithPinyinAndTrans[i][0];
        proposedWordData = lookupDataForWord(proposedWordChars);
        if (proposedWordData[2] !== '') {
          curWordData = proposedWordData;
        } else {
          output.push(curWordData);
          curWordData = wordsWithPinyinAndTrans[i];
        }
      }
      output.push(curWordData);
      return output;
    };
    groupWordsLong = function(wordsWithPinyinAndTrans) {
      var i, longestStartWord, nextWord, output, words, wordsOrig, wordsOrigToData, x, _i, _j, _len, _len1;
      longestStartWord = function(remainingList) {
        if (cdict.getPinyinForWord(remainingList.join('')) !== '') {
          return remainingList;
        }
        if (remainingList.length === 1) {
          return remainingList;
        }
        return longestStartWord(remainingList.slice(0, remainingList.length - 1));
      };
      wordsOrig = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = wordsWithPinyinAndTrans.length; _i < _len; _i++) {
          x = wordsWithPinyinAndTrans[_i];
          _results.push(x[0]);
        }
        return _results;
      })();
      words = [];
      i = 0;
      while (i < wordsOrig.length) {
        nextWord = longestStartWord(wordsOrig.slice(i));
        words.push(nextWord.join(''));
        i += nextWord.length;
      }
      output = [];
      wordsOrigToData = {};
      for (_i = 0, _len = wordsWithPinyinAndTrans.length; _i < _len; _i++) {
        x = wordsWithPinyinAndTrans[_i];
        wordsOrigToData[x[0]] = x;
      }
      for (_j = 0, _len1 = words.length; _j < _len1; _j++) {
        x = words[_j];
        if (wordsOrigToData[x] != null) {
          output.push(wordsOrigToData[x]);
        } else {
          output.push(lookupDataForWord(x));
        }
      }
      return output;
    };
    groupWordsLongPreservingPinyin = function(wordsWithPinyinAndTrans) {
      var i, longestStartWord, nextWord, output, words, wordsOrig, wordsOrigToData, x, _i, _j, _len, _len1;
      longestStartWord = function(remainingList) {
        var origPinyinForRemaining, pinyinForRemaining, x;
        pinyinForRemaining = pinyinutils.removeToneMarks(cdict.getPinyinForWord(((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = remainingList.length; _i < _len; _i++) {
            x = remainingList[_i];
            _results.push(x[0]);
          }
          return _results;
        })()).join('')).split(' ').join('').toLowerCase());
        origPinyinForRemaining = pinyinutils.removeToneMarks(((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = remainingList.length; _i < _len; _i++) {
            x = remainingList[_i];
            _results.push(x[1]);
          }
          return _results;
        })()).join('').split(' ').join('').toLowerCase());
        if (pinyinForRemaining === origPinyinForRemaining) {
          return remainingList;
        }
        if (remainingList.length === 1) {
          return remainingList;
        }
        return longestStartWord(remainingList.slice(0, remainingList.length - 1));
      };
      wordsOrig = wordsWithPinyinAndTrans;
      words = [];
      i = 0;
      while (i < wordsOrig.length) {
        nextWord = (function() {
          var _i, _len, _ref, _results;
          _ref = longestStartWord(wordsOrig.slice(i));
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            x = _ref[_i];
            _results.push(x[0]);
          }
          return _results;
        })();
        words.push(nextWord.join(''));
        i += nextWord.length;
      }
      output = [];
      wordsOrigToData = {};
      for (_i = 0, _len = wordsWithPinyinAndTrans.length; _i < _len; _i++) {
        x = wordsWithPinyinAndTrans[_i];
        wordsOrigToData[x[0]] = x;
      }
      for (_j = 0, _len1 = words.length; _j < _len1; _j++) {
        x = words[_j];
        if (wordsOrigToData[x] != null) {
          output.push(wordsOrigToData[x]);
        } else {
          output.push(lookupDataForWord(x));
        }
      }
      return output;
    };
    fixSegmentation = function(wordsWithPinyinAndTrans) {
      var allPinyin, cenglish, cpinyin, cword, english, output, pinyin, word, wordIdx, wordsList, _i, _j, _len, _len1, _ref;
      output = [];
      for (_i = 0, _len = wordsWithPinyinAndTrans.length; _i < _len; _i++) {
        _ref = wordsWithPinyinAndTrans[_i], word = _ref[0], pinyin = _ref[1], english = _ref[2];
        if (!english || english === '') {
          wordsList = cdict.getWordList(word);
          allPinyin = pinyin.split(' ');
          wordIdx = 0;
          for (_j = 0, _len1 = wordsList.length; _j < _len1; _j++) {
            cword = wordsList[_j];
            cpinyin = allPinyin.slice(wordIdx, wordIdx + cword.length).join(' ');
            cenglish = cdict.getEnglishForWordAndPinyin(cword, cpinyin);
            output.push([cword, cpinyin, cenglish]);
            wordIdx += cword.length;
          }
        } else {
          output.push([word, pinyin, english]);
        }
      }
      return output;
    };
    getSubPixAtTime = function(time, callback) {
      if (subPixGetter != null) {
        return callback(subPixGetter.subtitleAtTime(time));
      }
    };
    getFullAnnotatedSub = function(callback) {
      if (language.indexOf('zh') === 0) {
        return getFullAnnotatedSubChinese(callback);
      } else if (language.indexOf('ja') === 0) {
        return getFullAnnotatedSubJapanese(callback);
      } else {
        return getFullAnnotatedSubEnglish(callback);
      }
    };
    getNativeSubAtTime = function(time, callback) {
      var endTime, idx, midTime, startTime, subLine, _ref;
      idx = subtitleGetter.getSubtitleIndexFromTime(time);
      _ref = subtitleGetter.timesAndSubtitles[idx], startTime = _ref[0], endTime = _ref[1], subLine = _ref[2];
      midTime = Math.floor((startTime + endTime) / 2);
      return nativeSubtitleGetter.subtitleAtTimeAsync(midTime, callback);
    };
    getAnnotatedSubAtTime = function(time, callback) {
      if (language === 'zh') {
        getAnnotatedSubAtTimeChinese(time, callback);
      }
      if (language === 'ja') {
        getAnnotatedSubAtTimeJapanese(time, callback);
      }
      if (language === 'en') {
        return getAnnotatedSubAtTimeEnglish(time, callback);
      }
    };
    getAnnotatedSubAtTimeEnglish = function(time, callback) {
      var english_translations, idx, output, sub, word, word_list, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      sub = subtitleGetter.subtitleAtTime(time);
      if ((sub == null) || sub === '') {
        callback([]);
      }
      english_translations = [];
      word_list = edict.getWordList(sub);
      (function(_this) {
        return (function(__iced_k) {
          var _i, _len;
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/johnjackson/Desktop/Smart_Subtitles/Dongdonghua github 8-17-14/dongdonghua-master/aux.coffee"
          });
          for (idx = _i = 0, _len = word_list.length; _i < _len; idx = ++_i) {
            word = word_list[idx];
            translator.getTranslations(word, 'en', 'zh-CHS', __iced_deferrals.defer({
              assign_fn: (function(__slot_1, __slot_2) {
                return function() {
                  return __slot_1[__slot_2] = arguments[0];
                };
              })(english_translations, idx),
              lineno: 313
            }));
          }
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          var _i, _len;
          output = [];
          for (idx = _i = 0, _len = word_list.length; _i < _len; idx = ++_i) {
            word = word_list[idx];
            output.push([word, '', english_translations[idx][0].TranslatedText]);
          }
          return callback(output);
        };
      })(this));
    };
    getAnnotatedSubAtTimeJapanese = function(time, callback) {
      var sub;
      sub = subtitleGetter.subtitleAtTime(time);
      if ((sub == null) || sub === '') {
        callback([]);
      }
      return jdict.getGlossForSentence(sub, callback);
    };
    getGlossChinese = getchinese_gloss.getWordsPinyinEnglishCached;

    /*
    getGlossChinese = (sub, callback) ->
      processPinyin = (pinyin) ->
         *print pinyin
         *print sub
        havePinyin = pinyin.length > 0
        pinyin = fixPinyin(pinyin)
        pinyinNoTone = pinyinutils.removeToneMarks(pinyin)
        curPinyinWord = []
        words = []
        idx = 0
        curWord = []
         * how many characters to seek forward for a match in the pinyin
        defSeekRange = 3
        misSeekRange = 10
        curSeekRange = defSeekRange
        output = []
        
        endWord = ->
          tword = curWord.join('')
          tpinyin = curPinyinWord.join(' ')
          ttranslation = cdict.getEnglishForWordAndPinyin(tword, tpinyin)
          output.push([tword, tpinyin, ttranslation])
          curWord = []
          curPinyinWord = []
        
        for char in sub
          if char.trim() == ''
            continue
          if char == pinyin[idx..idx] or (char == '，' and pinyin[idx..idx] == ',') # punctuation
            endWord()
             *print 'punctuation:' + char + '|' + sub + '|' + time
            output.push([char, '', ''])
            ++idx
            continue
          if not cdict.wordLookup[char]?
            endWord()
             *print 'word lookup failed:' + char + '|' + sub + '|' + time
            output.push([char, '', ''])
            ++curSeekRange
            continue
          haveMatch = false
          for fidx in [0..curSeekRange]
            if haveMatch
              break
            nidx = idx + fidx
            havePinyinMatch = ->
              idx = nidx
              haveMatch = true
              curWord.push(char)
              curPinyinWord.push(pinyin[idx...idx+cpinyin.length])
              idx += cpinyin.length
              if idx >= pinyin.length or pinyin[idx] == ' ' # end of word
                endWord()
            for [cpinyin,english] in cdict.wordLookup[char]
              if haveMatch
                break
              if cpinyin == pinyin[nidx...nidx+cpinyin.length]
                havePinyinMatch()
                break
            for [cpinyin,english] in cdict.wordLookup[char]
              if haveMatch
                break
              cpinyin = pinyinutils.removeToneMarks(cpinyin)
              if cpinyin == pinyin[nidx...nidx+cpinyin.length]
                havePinyinMatch()
            for [cpinyin,english] in cdict.wordLookup[char]
              if haveMatch
                break
              cpinyin = cpinyin.toLowerCase()
              if cpinyin == pinyin[nidx...nidx+cpinyin.length]
                havePinyinMatch()
            for [cpinyin,english] in cdict.wordLookup[char]
              if haveMatch
                break
              cpinyin = pinyinutils.removeToneMarks(cpinyin.toLowerCase())
              if cpinyin == pinyin[nidx...nidx+cpinyin.length]
                havePinyinMatch()
            for [cpinyin,english] in cdict.wordLookup[char]
              if haveMatch
                break
              cpinyin = pinyinutils.removeToneMarks(cpinyin)
              if cpinyin == pinyinNoTone[nidx...nidx+cpinyin.length]
                havePinyinMatch()
            for [cpinyin,english] in cdict.wordLookup[char]
              if haveMatch
                break
              cpinyin = pinyinutils.removeToneMarks(cpinyin.toLowerCase())
              if cpinyin == pinyinNoTone[nidx...nidx+cpinyin.length]
                havePinyinMatch()
          if not haveMatch
             *print 'could not match:' + char + '|' + sub + '|' + time
            tpinyin = cdict.getPinyinForWord(char)
            ttranslation = cdict.getEnglishForWord(char)
            output.push([char, tpinyin, ttranslation])
            curSeekRange = misSeekRange
            continue
          else
            curSeekRange = defSeekRange
        output = fixSegmentation(output)
        if not havePinyin
          output = groupWordsLong(output)
        else
          output = groupWordsLongPreservingPinyin(output)
        callback(output)
    
      client.get('pinyin|' + sub, (err, rpinyin) ->
        if rpinyin? and rpinyin != ''
          processPinyin(rpinyin)
        else
          print 'not in redis:' + sub
          processPinyin('')
           *getpinyin.getPinyin(sub, (npinyin) ->
           *  processPinyin
           *)
      )
     */
    getAnnotatedSubAtTimeChinese = function(time, callback) {
      var sub;
      sub = subtitleGetter.subtitleAtTime(time);
      if ((sub == null) || sub === '') {
        callback([]);
        return;
      }
      return getGlossChinese(sub, callback);
    };
    getFullAnnotatedSubChinese = function(callback) {
      var allSubLines, annotatedSubLines, chineseGlossPromise, i, timesAndAnnotatedSubLines, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      allSubLines = subtitleGetter.getTimesAndSubtitles();
      chineseGlossPromise = deferred.promisify(getGlossChinese);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/johnjackson/Desktop/Smart_Subtitles/Dongdonghua github 8-17-14/dongdonghua-master/aux.coffee"
          });
          deferred.map(allSubLines, deferred.gate(function(e, i) {
            return chineseGlossPromise(e[2]);
          }, 1))(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return annotatedSubLines = arguments[0];
              };
            })(),
            lineno: 457
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          var _i, _ref;
          timesAndAnnotatedSubLines = [];
          for (i = _i = 0, _ref = allSubLines.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            timesAndAnnotatedSubLines[i] = [allSubLines[i][0], allSubLines[i][1], annotatedSubLines[i]];
          }
          return callback(timesAndAnnotatedSubLines);
        };
      })(this));
    };
    getFullAnnotatedSubJapanese = function(callback) {
      var allSubLines, annotatedSubLines, i, timesAndAnnotatedSubLines, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      allSubLines = subtitleGetter.getTimesAndSubtitles();
      annotatedSubLines = [];
      (function(_this) {
        return (function(__iced_k) {
          var _i, _ref;
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/johnjackson/Desktop/Smart_Subtitles/Dongdonghua github 8-17-14/dongdonghua-master/aux.coffee"
          });
          for (i = _i = 0, _ref = allSubLines.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            jdict.getGlossForSentence(allSubLines[i][2], __iced_deferrals.defer({
              assign_fn: (function(__slot_1, __slot_2) {
                return function() {
                  return __slot_1[__slot_2] = arguments[0];
                };
              })(annotatedSubLines, i),
              lineno: 476
            }));
          }
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          var _i, _ref;
          timesAndAnnotatedSubLines = [];
          for (i = _i = 0, _ref = allSubLines.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            timesAndAnnotatedSubLines[i] = [allSubLines[i][0], allSubLines[i][1], annotatedSubLines[i]];
          }
          return callback(timesAndAnnotatedSubLines);
        };
      })(this));
    };
    getFullAnnotatedSubEnglish = function(callback) {
      var allSubLines, annotatedSubLines, english_translations, i, idx, timesAndAnnotatedSubLines, word, word_list, ___iced_passed_deferral, __iced_deferrals, __iced_k, _begin, _end, _positive;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      allSubLines = subtitleGetter.getTimesAndSubtitles();
      annotatedSubLines = [];
      (function(_this) {
        return (function(__iced_k) {
          var _i, _results, _while;
          i = 0;
          _begin = 0;
          _end = allSubLines.length;
          _positive = _end > _begin;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                if (_positive) {
                  i += 1;
                } else {
                  i -= 1;
                }
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!!((_positive === true && i >= allSubLines.length) || (_positive === false && i <= allSubLines.length))) {
              return _break();
            } else {

              annotatedSubLines[i] = [];
              english_translations = [];
              word_list = edict.getWordList(allSubLines[i][2]);
              (function(__iced_k) {
                var _j, _len;
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/johnjackson/Desktop/Smart_Subtitles/Dongdonghua github 8-17-14/dongdonghua-master/aux.coffee"
                });
                for (idx = _j = 0, _len = word_list.length; _j < _len; idx = ++_j) {
                  word = word_list[idx];
                  translator.getTranslations(word, language, targetLanguage, __iced_deferrals.defer({
                    assign_fn: (function(__slot_1, __slot_2) {
                      return function() {
                        return __slot_1[__slot_2] = arguments[0];
                      };
                    })(english_translations, idx),
                    lineno: 491
                  }));
                }
                __iced_deferrals._fulfill();
              })(function() {
                var _j, _len;
                for (idx = _j = 0, _len = word_list.length; _j < _len; idx = ++_j) {
                  word = word_list[idx];
                  annotatedSubLines[i].push([word, '', english_translations[idx][0].TranslatedText]);
                }
                return _next();
              });
            }
          };
          _while(__iced_k);
        });
      })(this)((function(_this) {
        return function() {
          var _i, _ref;
          timesAndAnnotatedSubLines = [];
          for (i = _i = 0, _ref = allSubLines.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            timesAndAnnotatedSubLines[i] = [allSubLines[i][0], allSubLines[i][1], annotatedSubLines[i]];
          }
          return callback(timesAndAnnotatedSubLines);
        };
      })(this));
    };
    getTranslations = function(text, callback) {
      return translator.getTranslations(text, language, targetLanguage, callback);
    };
    nuser.now.getNativeSubAtTime = getNativeSubAtTime;
    nuser.now.getAnnotatedSubAtTime = getAnnotatedSubAtTime;
    nuser.now.getFullAnnotatedSub = getFullAnnotatedSub;
    nuser.now.getSubPixAtTime = getSubPixAtTime;
    nuser.now.getPrevDialogStartTime = getPrevDialogStartTime;
    nuser.now.getNextDialogStartTime = getNextDialogStartTime;
    nuser.now.initializeSubtitle = initializeSubtitle;
    nuser.now.initializeSubtitleText = initializeSubtitleText;
    nuser.now.initializeNativeSubtitle = initializeNativeSubtitle;
    nuser.now.initializeNativeSubtitleText = initializeNativeSubtitleText;
    nuser.now.initializeSubPix = initializeSubPix;
    nuser.now.downloadSubtitleText = downloadSubtitleText;
    nuser.now.getPrononciation = getprononciation.getPrononciationRateLimitedCached;
    nuser.now.getTranslations = getTranslations;
    return nuser.now.serverlog = serverlog = function(msg) {
      return console.log((new Date().getTime() / 1000).toString() + ' | ' + msg);
    };
  };

  main = function() {};

  if (require.main === module) {
    main();
  }

}).call(this);

//# sourceMappingURL=aux.map
